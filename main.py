print("lists[arry] in python!!!!!!!!!!!!!!!!!!!!!!")


# i = 0
# while i < len(lst):
#     i = i + 1
#     print(i)
lst = [2, 4, 5]
# append() მეთოდით, სიის ბოლოში ვამატებთ ელემენტს
lst.append("hello world")
lst.append(8)
lst.append(9)

# copy() მეთოდით, არსებულ სიას ვაკოპირებთ ახალ ცვლადში
# copy()-ს შემთხვევაში, თუკი, ახალ ელემენტს ვამატებთ სიაში და შემდგომ ვაკოპირებთ,
# ჩამატებულ ელემენტსაც წამოიღებს კოპირებულ ცვლადში, თუკი მას ჩავამატებთ მანამ სანამ დავაკოპირებთ სიას

# ხოლო თუკი ელემენტს ჩავამატებთ სიაში, მას შემდეგ რაც მას დავაკპირებთ, ახალი ჩამატებული ელემენტი,
# დაკოპირებულ ცვლადში არ აისახება, რადან copy() სიას ინაცავს სხვა მისამართზე
# განსხვავებით გატოლებისა=

# სისს გადმოკოპირების სხვა მეთოდია სია გავუტოლოთ ახალ ცვლადს, რომელიც სიას იმავე მისამართზე შეინახავს სხვა ცვლადში
# აღნიშნულში კი ელემენტის ჩამატება მოხდება, მიუხედავად იმისა ელემენტს გატოლების შემდეგ ჩავამატებთ თუ გატოლებამდე
# copy() სხვა მისმარტძე ინახავს ცვლადს/ გატოლებული= კი იმავე მისამართზე
# მაგალითად, copy() ში, ჩამატებული 10იანი არ აისახება, რადგანაც copy()ს შემდეგ ჩავამატეთ
copy_lst = lst.copy()
lst2 = lst
# lst.append(10)
lst.append(10)
print(lst)
print(copy_lst)
print(lst2)



# ჩაამატებს, იმავეს შვება extend(), მაგრამ, იგი გამოიყენებს ორი სიის გასაერთიანებლად, ან სიაში სიის ჩასამატებლად
united_list = [2, 90, 10]
new = united_list.extend(lst)
# ორ გაერთიენებლ სიას პირდაპირ ახალ ცვლადში ვერ შევინახავთ
# ჯერ უნდა გავაერთიანოთ და შემდეგ შევინხოთ ახალ ცვლადში
new = united_list
print(f"ორი სიის გაერთიანებით მივივღეთ:{new}")
# print(united_list)
print(f"ორი სიის გაერთიანებით მივივღეთ:{united_list}")
# extend() მეთოდით გავაეღტიანეთ lst[] და united_list სიები
# unisted_listში შევიტანეთ lst სია,
# extend()-ს ფრჩხილებში გადაეცემა იმ სიის ცვლადისს სახელი რომლის გაერთიანებაც გვინდა
# თკი სია ან ცარიელი სია არ გვაქვს შექმნილი, მასში extend() მეთოდით სიას ერ გავაერთიანებთ
# სია აუცილებლად უნდა იყოს შექმნილი
lst1 = ["hello world"]
lost = []
lost.extend(lst1)
lost.append(6)
print(lost)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# count() ითვლის იმ გადეცემულ ელემენტის რაოდენობას რომელსაც ფრჩხილებში
counted_list = united_list.count(10)
print(counted_list)
# 10 united_listში გვხვდება 2ჯერ

# შეგვიძლია სია for i inით გადავატეროთ და ისე დავთვალოთ
for j in united_list:
    print(united_list.count(j))
# რიგითობის მიხედვით გვიჩვენებს რომელი ელემენტი რამდენჯერ გვხვდება

# for გადავატერეთ new_listს, შემდგომ დავითვალეთ ის ელემენტები რომლებიც 1ზე მეტჯერ გვხვდებოდა ციკლში
# ბოლოს ამოვშალეთ ის ელემენტი რომელიც ერთზე მეტჯერ შეფგვხვდა
new_list = [2, 45, 6, 89, 6, 12, 34]
for i in new_list:
    if new_list.count(i) > 1:
        new_list.remove(i)
        # modified_list.append(i)
print(new_list)
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


# clear() გადაცემულ სიას  შლის, ასუფთავებს მას
print(new_list)
# print(new.clear())
# clear() მეთოდი არგუმენტს არ იღებს, მთლიანად ასუფთავებს მას


# თუკი კომკრეტული ელემტნის წაშლა გვინდა გვაქვს ორი მეთოდი
# 1: pop() რომეიც იმ ელემენტს შლის რომლის ინდექსსაც გადავცემთ
# და გვიპრინტავს ამოშლილ ელემენტს
print(new_list.pop(2))
popped_list = new_list.pop(1)
print(new_list.pop())
# თუკი პოპს არ გადავცემთ არგუმენტს, ბოლო ელე,ენტს ამოშლის
# pop() შლის მხოლოდ ერთ ელემენტს და მას არ გადაეცემა არც ბიჯი და არც ორი ელემენტი
print(popped_list)
# შეგვიძლია ამოშლილი ელემენტი ახალ ცვლადში შევინახოთ და ისე დავპრინტოთ


# 2: remove() მეთოდი იმ ელემენტს შლის რომელსაც გადავცემთ
# remove() ფრჩხიებში გადაეცემა ელემენტის დასახელება
new_list.append(45)
print(new_list)
new_list.remove(45)
print(new_list)
# განხსვავებით pop()სა, remove()შლის ელემენტს სიიდან, და დარჩენილ სია გამოაქვს
# მსგავსად pop()სა, remove()ც ერთ არგუმენტს იღებს და არა ორს
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# index() - გამოქვს გადაცემული ელე,ენტის რიგითობის ნომერი
# ფრჩხილებში გადაეცემა ელემენტის სახელი - გადაცემული ელემენტის რიგითობას გვიჩვენებს
united_list.append(2)
print(united_list)
print(f"united_listში, ელემენტი 2ის რიგითობის ნომერია {united_list.index(10)}")
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# reverse() სიას ამობრუნებს და შემატრიალებს
# united_list = united_list.reverse()
reversed_list = united_list[::-1]
print(reversed_list)
# შეგვიძლია range()ბიჯების სახით ამოვატრიალოთ სია, ან გამოვიყენოთ reverse()მეთოდი
# ჯერ ამოვაბრუნეთ სია reverse() მოთოდით, რომელიც შემდგომ გადავაკოპირეთ ახალ ცვლადში
united_list.reverse()
reversed_list = united_list.copy()
print(f"united_list ის ამოტრიალებული სია არის {reversed_list}")

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# sort() მეთოდი ალაგებს სიის ელემენტებს კოპმკრეტული არგუმნტის მიხედვით
# defaultად აქვს რომ ანბანის მიხედვით დააალადოს
sort_list = ["hello world", "malkhaz", "nika", "lasha", "beqa", "yvera", "procha"]
sort_list.sort()
print(sort_list)
# ანბანის მიხსდვით დალაგებული სია
# sort() მმეთოდი მოქმედებს იმ შემთხვევაში თუკი ერთო ტიპის ელემენტები გვაქვს სიაში


# ზრდადობის მიხედვით დალადგებული ელემენტების სია
numbers_list = [1, 34, 5.6, 21, 54, 5, 8, 9 ,23, 47]
for i in numbers_list:
    if i < i+1 :
        numbers_list.sort()
    # numbers_list.sort(numbers_list > i)
print(numbers_list)




# enumerate() მეთოდი სათითაოდ გამოაქვს სიის მნიშვნელობა და მათი ინდექსი,
# forში ვქმნით ორ ცვლადს, პირველი ცვლადი აღნიშნავს ინდექსს, მეორე მნიშვნელობას,
# ორი ცვლადი მძიმით, უნდა გამოიყოს ერთმანეთისგან
# sort_list.extend(numbers_list)
# print(sort_list)
for i, j in enumerate(numbers_list):
    print(f"index - {i}, value - {j}")



# თუკი enuremate მეთოდში გამოვიყენებთ ერთ ცვლადს
for j in enumerate(numbers_list):
    print(j)
# მნშივნელობას და ინდექსს გამოგვიტანს ერთად, tupleს მსგავს ცვლადში, ტაპლის მსგავს სიასში
# ინდექსს და მნიშვნელობას კი გამოფოყს მძიმით



# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# სეიბის გენერატორი: სიების დაგენერერირების მოკლე გზა
lists = list()
for i in range(1, 11):
    lists.append(i)
print(lists)
# print(lists)
# 1: ჯერ ვწერთ იმ ცვლადს რომელიც გვიწერია append() ის ფრჩხილებში,
# 2: for ციკლს ვიძეხებთ rangeით,
# 3: თუ გვინდა ბოლოში გამოვიძახებთ if/else
# სიების გენერატროით შექმნილი მიკლე კოდი
# for ის წინ უნდა დავწეროთ იგივე ცვლადი რასაც ვიძახებთ for() ციკლში
# რა ვლადსაც ვიძახებთ იმავე ცვლაბს ვიყენებთ
lsti = [i for i in range(1, 11)]
print(lsti)
lis = [i for elem in range(1 ,11)]
# რადგანაც forში შევქმენით elem, for()ის წინაც უნდა გამოვიყენოთ elem და არა
print(f"გენერირებული{lis}")

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
int1 = int(input("რიცხვი1: "))
int2 = int(input("რიცხვი2: "))
ist1 = []
for i in range(int1, int2):
    if i % 2 == 0:
        ist1.append(i)
print(ist1)
# მოკლე ჩანაწერი იქნებოდა შემდეგი
lsts = [i for i in range(int1, int2) if i % 2 == 0]
print(lsts)
# თუ გვინდა მათი ახარისხება, პირველ i-ს დავუწერთ ** ორ ფიფქს და ხარისხის ნიშანს,
lsts = [i**2 for i in range(int1, int2) if i % 2 == 0]
print(lsts)


# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# matrix: სიაში ჩადგმული რამდენიმე სია
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
]
# სიაში რომ სიის რომელი ელემენტს მივწვდეთ საჭიროა ინდექსაცია
print(matrix[1][2])
# პირველი [] აღნიშნავს სიის ინდექსს
# მეორე [], კი სიაში, მერამდენე სიაც გვინდა იმ სიის ინდექსს

# აგრეთვე შეგვიძლია სიის, სიაში > სია შევქმნათ
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, [8.1, 8.2, 8.3 ], 9],
]
print(f"{matrix[2][2][1]}აღნიშნული ინდექსცია გამოიტანს - 8.2")
# პირველი [] მივწვდებით, სიაში, სიას > მაგ ინდექს 2 აღნიშნავს [7, 8, [8.1, 8.2, 8.3 ], 9] ამ სიას
# მეორე [] შეგვიძლია მივწვდეთ ან რომეიმე ელემენტს ან ამ სიაში არსებულ სიასს
# მაგ:მეორე [2] აღნიშნავს სიას რომელიც აქ გვაქვს შექმნილი [8.1, 8.2, 8.3 ]
# უ გვინდა რომ რომელიმე ელემენტს მივწვდეთ დაგვჭირდება მესამე იდექსაციაც []








